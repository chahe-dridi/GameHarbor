/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ResponseCodeEnum} HashgraphProto.proto.ResponseCodeEnum
 */
declare class Status {
    /**
     * @internal
     * @param {number} code
     * @returns {Status}
     */
    static _fromCode(code: number): Status;
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code: number);
    /** @readonly */
    readonly _code: number;
    /**
     * @returns {string}
     */
    toString(): string;
    /**
     * @returns {HashgraphProto.proto.ResponseCodeEnum}
     */
    valueOf(): HashgraphProto.proto.ResponseCodeEnum;
}
declare namespace Status {
    let Ok: Status;
    let InvalidTransaction: Status;
    let PayerAccountNotFound: Status;
    let InvalidNodeAccount: Status;
    let TransactionExpired: Status;
    let InvalidTransactionStart: Status;
    let InvalidTransactionDuration: Status;
    let InvalidSignature: Status;
    let MemoTooLong: Status;
    let InsufficientTxFee: Status;
    let InsufficientPayerBalance: Status;
    let DuplicateTransaction: Status;
    let Busy: Status;
    let NotSupported: Status;
    let InvalidFileId: Status;
    let InvalidAccountId: Status;
    let InvalidContractId: Status;
    let InvalidTransactionId: Status;
    let ReceiptNotFound: Status;
    let RecordNotFound: Status;
    let InvalidSolidityId: Status;
    let Unknown: Status;
    let Success: Status;
    let FailInvalid: Status;
    let FailFee: Status;
    let FailBalance: Status;
    let KeyRequired: Status;
    let BadEncoding: Status;
    let InsufficientAccountBalance: Status;
    let InvalidSolidityAddress: Status;
    let InsufficientGas: Status;
    let ContractSizeLimitExceeded: Status;
    let LocalCallModificationException: Status;
    let ContractRevertExecuted: Status;
    let ContractExecutionException: Status;
    let InvalidReceivingNodeAccount: Status;
    let MissingQueryHeader: Status;
    let AccountUpdateFailed: Status;
    let InvalidKeyEncoding: Status;
    let NullSolidityAddress: Status;
    let ContractUpdateFailed: Status;
    let InvalidQueryHeader: Status;
    let InvalidFeeSubmitted: Status;
    let InvalidPayerSignature: Status;
    let KeyNotProvided: Status;
    let InvalidExpirationTime: Status;
    let NoWaclKey: Status;
    let FileContentEmpty: Status;
    let InvalidAccountAmounts: Status;
    let EmptyTransactionBody: Status;
    let InvalidTransactionBody: Status;
    let InvalidSignatureTypeMismatchingKey: Status;
    let InvalidSignatureCountMismatchingKey: Status;
    let EmptyLiveHashBody: Status;
    let EmptyLiveHash: Status;
    let EmptyLiveHashKeys: Status;
    let InvalidLiveHashSize: Status;
    let EmptyQueryBody: Status;
    let EmptyLiveHashQuery: Status;
    let LiveHashNotFound: Status;
    let AccountIdDoesNotExist: Status;
    let LiveHashAlreadyExists: Status;
    let InvalidFileWacl: Status;
    let SerializationFailed: Status;
    let TransactionOversize: Status;
    let TransactionTooManyLayers: Status;
    let ContractDeleted: Status;
    let PlatformNotActive: Status;
    let KeyPrefixMismatch: Status;
    let PlatformTransactionNotCreated: Status;
    let InvalidRenewalPeriod: Status;
    let InvalidPayerAccountId: Status;
    let AccountDeleted: Status;
    let FileDeleted: Status;
    let AccountRepeatedInAccountAmounts: Status;
    let SettingNegativeAccountBalance: Status;
    let ObtainerRequired: Status;
    let ObtainerSameContractId: Status;
    let ObtainerDoesNotExist: Status;
    let ModifyingImmutableContract: Status;
    let FileSystemException: Status;
    let AutorenewDurationNotInRange: Status;
    let ErrorDecodingBytestring: Status;
    let ContractFileEmpty: Status;
    let ContractBytecodeEmpty: Status;
    let InvalidInitialBalance: Status;
    let InvalidReceiveRecordThreshold: Status;
    let InvalidSendRecordThreshold: Status;
    let AccountIsNotGenesisAccount: Status;
    let PayerAccountUnauthorized: Status;
    let InvalidFreezeTransactionBody: Status;
    let FreezeTransactionBodyNotFound: Status;
    let TransferListSizeLimitExceeded: Status;
    let ResultSizeLimitExceeded: Status;
    let NotSpecialAccount: Status;
    let ContractNegativeGas: Status;
    let ContractNegativeValue: Status;
    let InvalidFeeFile: Status;
    let InvalidExchangeRateFile: Status;
    let InsufficientLocalCallGas: Status;
    let EntityNotAllowedToDelete: Status;
    let AuthorizationFailed: Status;
    let FileUploadedProtoInvalid: Status;
    let FileUploadedProtoNotSavedToDisk: Status;
    let FeeScheduleFilePartUploaded: Status;
    let ExchangeRateChangeLimitExceeded: Status;
    let MaxContractStorageExceeded: Status;
    let TransferAccountSameAsDeleteAccount: Status;
    let TotalLedgerBalanceInvalid: Status;
    let ExpirationReductionNotAllowed: Status;
    let MaxGasLimitExceeded: Status;
    let MaxFileSizeExceeded: Status;
    let ReceiverSigRequired: Status;
    let InvalidTopicId: Status;
    let InvalidAdminKey: Status;
    let InvalidSubmitKey: Status;
    let Unauthorized: Status;
    let InvalidTopicMessage: Status;
    let InvalidAutorenewAccount: Status;
    let AutorenewAccountNotAllowed: Status;
    let TopicExpired: Status;
    let InvalidChunkNumber: Status;
    let InvalidChunkTransactionId: Status;
    let AccountFrozenForToken: Status;
    let TokensPerAccountLimitExceeded: Status;
    let InvalidTokenId: Status;
    let InvalidTokenDecimals: Status;
    let InvalidTokenInitialSupply: Status;
    let InvalidTreasuryAccountForToken: Status;
    let InvalidTokenSymbol: Status;
    let TokenHasNoFreezeKey: Status;
    let TransfersNotZeroSumForToken: Status;
    let MissingTokenSymbol: Status;
    let TokenSymbolTooLong: Status;
    let AccountKycNotGrantedForToken: Status;
    let TokenHasNoKycKey: Status;
    let InsufficientTokenBalance: Status;
    let TokenWasDeleted: Status;
    let TokenHasNoSupplyKey: Status;
    let TokenHasNoWipeKey: Status;
    let InvalidTokenMintAmount: Status;
    let InvalidTokenBurnAmount: Status;
    let TokenNotAssociatedToAccount: Status;
    let CannotWipeTokenTreasuryAccount: Status;
    let InvalidKycKey: Status;
    let InvalidWipeKey: Status;
    let InvalidFreezeKey: Status;
    let InvalidSupplyKey: Status;
    let MissingTokenName: Status;
    let TokenNameTooLong: Status;
    let InvalidWipingAmount: Status;
    let TokenIsImmutable: Status;
    let TokenAlreadyAssociatedToAccount: Status;
    let TransactionRequiresZeroTokenBalances: Status;
    let AccountIsTreasury: Status;
    let TokenIdRepeatedInTokenList: Status;
    let TokenTransferListSizeLimitExceeded: Status;
    let EmptyTokenTransferBody: Status;
    let EmptyTokenTransferAccountAmounts: Status;
    let InvalidScheduleId: Status;
    let ScheduleIsImmutable: Status;
    let InvalidSchedulePayerId: Status;
    let InvalidScheduleAccountId: Status;
    let NoNewValidSignatures: Status;
    let UnresolvableRequiredSigners: Status;
    let ScheduledTransactionNotInWhitelist: Status;
    let SomeSignaturesWereInvalid: Status;
    let TransactionIdFieldNotAllowed: Status;
    let IdenticalScheduleAlreadyCreated: Status;
    let InvalidZeroByteInString: Status;
    let ScheduleAlreadyDeleted: Status;
    let ScheduleAlreadyExecuted: Status;
    let MessageSizeTooLarge: Status;
    let OperationRepeatedInBucketGroups: Status;
    let BucketCapacityOverflow: Status;
    let NodeCapacityNotSufficientForOperation: Status;
    let BucketHasNoThrottleGroups: Status;
    let ThrottleGroupHasZeroOpsPerSec: Status;
    let SuccessButMissingExpectedOperation: Status;
    let UnparseableThrottleDefinitions: Status;
    let InvalidThrottleDefinitions: Status;
    let AccountExpiredAndPendingRemoval: Status;
    let InvalidTokenMaxSupply: Status;
    let InvalidTokenNftSerialNumber: Status;
    let InvalidNftId: Status;
    let MetadataTooLong: Status;
    let BatchSizeLimitExceeded: Status;
    let InvalidQueryRange: Status;
    let FractionDividesByZero: Status;
    let InsufficientPayerBalanceForCustomFee: Status;
    let CustomFeesListTooLong: Status;
    let InvalidCustomFeeCollector: Status;
    let InvalidTokenIdInCustomFees: Status;
    let TokenNotAssociatedToFeeCollector: Status;
    let TokenMaxSupplyReached: Status;
    let SenderDoesNotOwnNftSerialNo: Status;
    let CustomFeeNotFullySpecified: Status;
    let CustomFeeMustBePositive: Status;
    let TokenHasNoFeeScheduleKey: Status;
    let CustomFeeOutsideNumericRange: Status;
    let RoyaltyFractionCannotExceedOne: Status;
    let FractionalFeeMaxAmountLessThanMinAmount: Status;
    let CustomScheduleAlreadyHasNoFees: Status;
    let CustomFeeDenominationMustBeFungibleCommon: Status;
    let CustomFractionalFeeOnlyAllowedForFungibleCommon: Status;
    let InvalidCustomFeeScheduleKey: Status;
    let InvalidTokenMintMetadata: Status;
    let InvalidTokenBurnMetadata: Status;
    let CurrentTreasuryStillOwnsNfts: Status;
    let AccountStillOwnsNfts: Status;
    let TreasuryMustOwnBurnedNft: Status;
    let AccountDoesNotOwnWipedNft: Status;
    let AccountAmountTransfersOnlyAllowedForFungibleCommon: Status;
    let MaxNftsInPriceRegimeHaveBeenMinted: Status;
    let PayerAccountDeleted: Status;
    let CustomFeeChargingExceededMaxRecursionDepth: Status;
    let CustomFeeChargingExceededMaxAccountAmounts: Status;
    let InsufficientSenderAccountBalanceForCustomFee: Status;
    let SerialNumberLimitReached: Status;
    let CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique: Status;
    let NoRemainingAutomaticAssociations: Status;
    let ExistingAutomaticAssociationsExceedGivenLimit: Status;
    let RequestedNumAutomaticAssociationsExceedsAssociationLimit: Status;
    let TokenIsPaused: Status;
    let TokenHasNoPauseKey: Status;
    let InvalidPauseKey: Status;
    let FreezeUpdateFileDoesNotExist: Status;
    let FreezeUpdateFileHashDoesNotMatch: Status;
    let NoUpgradeHasBeenPrepared: Status;
    let NoFreezeIsScheduled: Status;
    let UpdateFileHashChangedSincePrepareUpgrade: Status;
    let FreezeStartTimeMustBeFuture: Status;
    let PreparedUpdateFileIsImmutable: Status;
    let FreezeAlreadyScheduled: Status;
    let FreezeUpgradeInProgress: Status;
    let UpdateFileIdDoesNotMatchPrepared: Status;
    let UpdateFileHashDoesNotMatchPrepared: Status;
    let ConsensusGasExhausted: Status;
    let RevertedSuccess: Status;
    let MaxStorageInPriceRegimeHasBeenUsed: Status;
    let InvalidAliasKey: Status;
    let UnexpectedTokenDecimals: Status;
    let InvalidProxyAccountId: Status;
    let InvalidTransferAccountId: Status;
    let InvalidFeeCollectorAccountId: Status;
    let AliasIsImmutable: Status;
    let SpenderAccountSameAsOwner: Status;
    let AmountExceedsTokenMaxSupply: Status;
    let NegativeAllowanceAmount: Status;
    let CannotApproveForAllFungibleCommon: Status;
    let SpenderDoesNotHaveAllowance: Status;
    let AmountExceedsAllowance: Status;
    let MaxAllowancesExceeded: Status;
    let EmptyAllowances: Status;
    let SpenderAccountRepeatedInAllowances: Status;
    let RepeatedSerialNumsInNftAllowances: Status;
    let FungibleTokenInNftAllowances: Status;
    let NftInFungibleTokenAllowances: Status;
    let InvalidAllowanceOwnerId: Status;
    let InvalidAllowanceSpenderId: Status;
    let RepeatedAllowancesToDelete: Status;
    let InvalidDelegatingSpender: Status;
    let DelegatingSpenderCannotGrantApproveForAll: Status;
    let DelegatingSpenderDoesNotHaveApproveForAll: Status;
    let ScheduleExpirationTimeTooFarInFuture: Status;
    let ScheduleExpirationTimeMustBeHigherThanConsensusTime: Status;
    let ScheduleFutureThrottleExceeded: Status;
    let ScheduleFutureGasLimitExceeded: Status;
    let InvalidEthereumTransaction: Status;
    let WrongChainId: Status;
    let WrongNonce: Status;
    let AccessListUnsupported: Status;
    let SchedulePendingExpiration: Status;
    let ContractIsTokenTreasury: Status;
    let ContractHasNonZeroTokenBalances: Status;
    let ContractExpiredAndPendingRemoval: Status;
    let ContractHasNoAutoRenewAccount: Status;
    let PermanentRemovalRequiresSystemInitiation: Status;
    let ProxyAccountIdFieldIsDeprecated: Status;
    let SelfStakingIsNotAllowed: Status;
    let InvalidStakingId: Status;
    let StakingNotEnabled: Status;
    let InvalidPrngRange: Status;
    let MaxEntitiesInPriceRegimeHaveBeenCreated: Status;
    let InvalidFullPrefixSignatureForPrecompile: Status;
    let InsufficientBalancesForStorageRent: Status;
    let MaxChildRecordsExceeded: Status;
    let InsufficientBalancesForRenewalFees: Status;
    let TransactionHasUnknownFields: Status;
    let AccountIsImmutable: Status;
    let AliasAlreadyAssigned: Status;
}
export default Status;
export namespace HashgraphProto {
    namespace proto {
        type ResponseCodeEnum = import("@hashgraph/proto").proto.ResponseCodeEnum;
    }
}
